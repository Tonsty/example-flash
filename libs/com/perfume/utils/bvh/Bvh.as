package com.perfume.utils.bvh{	import __AS3__.vec.Vector;
	
	import flash.geom.Matrix3D;
	import flash.geom.Vector3D;	use namespace prfmbvh;	public class Bvh{		public var isLoop:Boolean;				private var _rootBone:BvhBone;		prfmbvh function set rootBone(__bone:BvhBone):void{ _rootBone = __bone; }				private var _frames:Vector.<Vector.<Number>>;		prfmbvh function set frames(__frames:Vector.<Vector.<Number>>):void{ _frames = __frames; }				private var _numFrames:uint;		public function get numFrames():Number { return _numFrames; }		prfmbvh function set numFramesInternal(_num:Number):void { _numFrames = _num; }				private var _frameTime:Number;		public function get frameTime():Number { return _frameTime; }		prfmbvh function set frameTimeInternal(_num:Number):void { _frameTime = _num; }				private var _bones:Vector.<BvhBone>;		public function get bones():Vector.<BvhBone> { return _bones; }				public function Bvh(_str:String) {			_bones = new Vector.<BvhBone>();			new BvhParser(this, _str);		}				public function destroy():void {			_bones = null;			_frames = null;			_rootBone = null;		}				public function gotoFrame(_frame:uint):void {			if (!isLoop) {				if (_frame >= _numFrames) _frame = _numFrames-1;			} else {				while (_frame >= _numFrames) _frame -= _numFrames;				}			var frame:Vector.<Number> = _frames[_frame];			var numFrame:int = frame.length;			var count:int = 0;			var i:int;			var l:int;			for each (var _bone:BvhBone in _bones) {				l = _bone.numChannels;				for ( i=0; i<l; i++ ) {					if ( count < numFrame ) {						_bone[_bone.channels[i]] = frame[count];						count++;					}				}			}		}				public function reposition():void{			for each (var bone:BvhBone in bones) {				var _p0:BvhBone = bone;				var matrix:Matrix3D = new Matrix3D();				calcBonePosition(bone, matrix);				_p0.translatedX = matrix.position.x;				_p0.translatedY = matrix.position.y;				_p0.translatedZ = -matrix.position.z;								if ( _p0.isEnd ) {// endSite					bone = _p0;					matrix.identity();					matrix.appendTranslation(bone.endOffsetX, bone.endOffsetY, -bone.endOffsetZ);					calcBonePosition(bone, matrix);					_p0.endTranslatedX = matrix.position.x;					_p0.endTranslatedY = matrix.position.y;					_p0.endTranslatedZ = -matrix.position.z;				}			}		}				private function calcBonePosition(bone:BvhBone, matrix:Matrix3D):void{			// coordinate system in BVH is right-handed.			while ( bone ) {				matrix.appendRotation(bone.Zrotation, Vector3D.Z_AXIS);				matrix.appendRotation(-bone.Xrotation, Vector3D.X_AXIS);				matrix.appendRotation(-bone.Yrotation, Vector3D.Y_AXIS);				matrix.appendTranslation(bone.Xposition+bone.offsetX, bone.Yposition+bone.offsetY, -(bone.Zposition+bone.offsetZ));				bone = bone.parent;			}			// if BVH's coordinate system is left-handed then use below.			/*			while ( bone ) {				matrix.appendRotation(bone.Yrotation, Vector3D.Y_AXIS);				matrix.appendRotation(bone.Xrotation, Vector3D.X_AXIS);				matrix.appendRotation(bone.Zrotation, Vector3D.Z_AXIS);				matrix.appendTranslation(bone.Xposition+bone.offsetX, bone.Yposition+bone.offsetY, bone.Zposition+bone.offsetZ);				bone = bone.parent;			}			*/		}	}}